<!-- component -->
<style>
  #journal-scroll::-webkit-scrollbar {
            width: 4px;
            cursor: pointer;
            /*background-color: rgba(229, 231, 235, var(--bg-opacity));*/

        }
        #journal-scroll::-webkit-scrollbar-track {
            background-color: rgba(229, 231, 235, var(--bg-opacity));
            cursor: pointer;
            /*background: red;*/
        }
        #journal-scroll::-webkit-scrollbar-thumb {
            cursor: pointer;
            background-color: #a0aec0;
            /*outline: 1px solid slategrey;*/
        }
</style>



<div class="max-w-3xl mx-auto py-10 px-2">
    <div class="bg-white rounded-2xl shadow p-4">
        <div class="text-4xl font-extralight text-black px-5 py-2 border-b border-black border-b-2">
            Upcoming Readings
        </div>
        <div class="overflow-auto" id="journal-scroll">
            <table class="w-full">
                <tbody>
{% set readings = publicreading if publicreading else [] %}
{% set current = nextReading %}
{% set startIndex = 0 %}
{% if current %}
    {# iterate readings to compute startIndex; output suppressed in production #}
    {% for r in readings %}
        {% if r.date == current.date %}{% set startIndex = loop.index0 + 1 %}{% endif %}
    {% endfor %}
{% endif %}
{% set total = readings | length %}
{% for reading in readings %}
        <tr class="text-xs border-b border-black hover:bg-blue-50 transition" data-pr-index="{{ loop.index0 }}">
                <td class="pl-5 pr-3 py-3 align-top w-1/4">
                        <div class="font-black text-black text-lg">{{ reading.date }}</div>
                        <div class="font-extralight text-sm text-black">{{ reading.torahTitle }}</div>
                </td>
                <td class="px-2 py-3 align-top w-2/4">
                        <div class="text-gray-900 font-extralight text-lg w-full"><span class="font-black lowercase text-sm">torah: </span>{{ reading.torahPassage }} <span class="bg-black rounded-full inline-block text-white font-black px-2 text-sm">{{reading.torahVerseTotal}} </div>
                        <div class="text-gray-900 font-extralight text-lg w-full"><span class="font-black lowercase text-sm">gospel: </span>{{ reading.gospelPassage }} <span class="bg-black rounded-full inline-block text-white font-black px-2 text-sm">{{reading.gospelVerseTotal}} </div>
                       
                         
                </td>
                <td class="px-2 py-3 align-top w-1/4">
                    <a href="/public-reading/{{ reading.slug }}/" class="inline-block text-black bg-green-500 hover:bg-yellow-300 focus:outline-none focus:ring-4 focus:ring-green-500 font-medium rounded-full text-sm px-5 py-2.5 text-center me-2 mb-2 dark:focus:ring-green-500 border-black border-2">Read This!</a>
                </td>
        </tr>
{% endfor %}
                </tbody>
            </table>
        </div>
    </div>
</div>

<!-- Client-side pagination controls (10 items per page) -->
<div class="max-w-3xl mx-auto py-6 px-2">
    <nav id="pr-pager" data-start-index="{{ startIndex }}" class="flex items-center justify-center gap-2" aria-label="Pagination"></nav>
</div>

<script>
    (function(){
        const pageSize = 10;
        const tbody = document.currentScript ? document.currentScript.parentNode.querySelector('table tbody') : document.querySelector('#journal-scroll table tbody');
        if (!tbody) return;
        const rows = Array.from(tbody.querySelectorAll('tr[data-pr-index]'));
        const total = rows.length;
        if (total === 0) return;
        const totalPages = Math.ceil(total / pageSize);

        const pager = document.getElementById('pr-pager');
        if (!pager) return;

        // server-provided startIndex (row index to prefer)
        let startIndex = 0;
        if (pager.dataset && pager.dataset.startIndex) {
            const s = parseInt(pager.dataset.startIndex, 10);
            if (!isNaN(s)) startIndex = s;
        }

        // If hash present, use it (deep-link): #page=2 (1-based)
        function pageFromHash() {
            const h = location.hash.replace(/^#/, '');
            const m = h.match(/page=(\d+)/);
            if (m) return Math.max(0, parseInt(m[1], 10) - 1);
            return null;
        }

        let initialPage = pageFromHash();
        if (initialPage === null) {
            // page that contains startIndex
            initialPage = Math.floor(startIndex / pageSize) || 0;
        }
        let currentPage = Math.min(Math.max(0, initialPage), totalPages - 1);

        function showPage(page, alignToStartIndex) {
            let start = page * pageSize;
            if (alignToStartIndex && startIndex > 0) {
                // align whole page so that startIndex is included on that page
                const containing = Math.floor(startIndex / pageSize);
                start = containing * pageSize;
            }
            const end = start + pageSize;
            rows.forEach((r, idx) => r.style.display = (idx >= start && idx < end) ? '' : 'none');
            currentPage = Math.floor(start / pageSize);
            buildPager(currentPage);
            // update hash for deep-linking
            history.replaceState(null, '', `#page=${currentPage + 1}`);
        }

        function buildPager(activePage) {
            pager.innerHTML = '';
            const prev = document.createElement('button');
            prev.textContent = 'Prev';
            prev.className = 'px-3 py-2 rounded border bg-white text-gray-900';
            prev.disabled = activePage === 0;
            prev.addEventListener('click', () => { if (activePage > 0) showPage(activePage - 1); });
            pager.appendChild(prev);

            const maxButtons = 7;
            let start = Math.max(0, activePage - 3);
            let finish = Math.min(totalPages - 1, start + maxButtons - 1);
            if (finish - start + 1 < maxButtons) {
                start = Math.max(0, finish - maxButtons + 1);
            }
            for (let i = start; i <= finish; i++) {
                const btn = document.createElement('button');
                btn.textContent = (i + 1).toString();
                btn.className = (i === activePage) ? 'px-3 py-2 rounded bg-gray-900 text-white' : 'px-3 py-2 rounded bg-white text-gray-900 border';
                btn.addEventListener('click', () => showPage(i));
                pager.appendChild(btn);
            }

            const next = document.createElement('button');
            next.textContent = 'Next';
            next.className = 'px-3 py-2 rounded border bg-white text-gray-900';
            next.disabled = activePage >= totalPages - 1;
            next.addEventListener('click', () => { if (activePage < totalPages - 1) showPage(activePage + 1); });
            pager.appendChild(next);
        }

        // react to back/forward
        window.addEventListener('hashchange', () => {
            const p = pageFromHash();
            if (p !== null) showPage(Math.min(Math.max(0, p), totalPages - 1));
        });

        // initial render: ensure the page that contains startIndex is shown (full page)
        showPage(currentPage, true);
    })();
</script>